(* generated by Ott 0.10.17 ***locally nameless*** from: terms.ott *)

Require Import Metatheory.

(** syntax *)
Definition x := var.
Definition l := atom.

Inductive k : Set := 
 | k_true : k
 | k_false : k
 | k_others : k.

Inductive B : Set := 
 | B_bool : B
 | B_others : B.

Inductive b : Set := 
 | b_blame : l -> b.

Inductive s : Set := 
 | s_var_b : nat -> s
 | s_var_f : x -> s
 | s_const : k -> s
 | s_lam : SS -> s -> s
 | s_app : s -> s -> s
 | s_blame : b -> s
 | s_cast : SS -> SS -> l -> s
 | s_check : SS -> s -> k -> l -> s
with SS : Set := 
 | SS_refinement : B -> s -> SS
 | SS_darrow : SS -> SS -> SS.

Inductive F : Set := 
 | F_appl : s -> F
 | F_appr : s -> F
 | F_check : SS -> k -> l -> F.

(* EXPERIMENTAL *)

(** subrules *)
Definition is_FS_of_SS (SS_6:SS) : Prop :=
  match SS_6 with
  | (SS_refinement B5 s5) => False
  | (SS_darrow SS1 SS2) => (True)
end.

Definition is_h_of_s (s_6:s) : Prop :=
  match s_6 with
  | (s_var_b nat) => False
  | (s_var_f x5) => False
  | (s_const k5) => False
  | (s_lam SS5 s5) => False
  | (s_app s5 s') => False
  | (s_blame b5) => False
  | (s_cast SS1 SS2 l5) => ((is_FS_of_SS SS1) /\ (is_FS_of_SS SS2))
  | (s_check SS5 s5 k5 l5) => False
end.

Fixpoint is_w_of_s (s_6:s) : Prop :=
  match s_6 with
  | (s_var_b nat) => False
  | (s_var_f x5) => False
  | (s_const k5) => (True)
  | (s_lam SS5 s5) => (True)
  | (s_app s5 s') => ((is_h_of_s s5) /\ (is_w_of_s s'))
  | (s_blame b5) => False
  | (s_cast SS1 SS2 l5) => (True)
  | (s_check SS5 s5 k5 l5) => False
end.

Definition is_q_of_s (s_6:s) : Prop :=
  match s_6 with
  | (s_var_b nat) => False
  | (s_var_f x5) => False
  | (s_const k5) => (True)
  | (s_lam SS5 s5) => (True)
  | (s_app s5 s') => ((is_h_of_s s5) /\ (is_w_of_s s'))
  | (s_blame b5) => (True)
  | (s_cast SS1 SS2 l5) => (True)
  | (s_check SS5 s5 k5 l5) => False
end.


(** opening up abstractions *)
Fixpoint open_s_wrt_s_rec (k:nat) (s_6:s) (s__7:s) {struct s__7}: s :=
  match s__7 with
  | (s_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => s_var_b nat
        | inleft (right _) => s_6
        | inright _ => s_var_b (nat - 1)
      end
  | (s_var_f x5) => s_var_f x5
  | (s_const k5) => s_const k5
  | (s_lam SS5 s5) => s_lam (open_SS_wrt_s_rec k s_6 SS5) (open_s_wrt_s_rec (S k) s_6 s5)
  | (s_app s5 s') => s_app (open_s_wrt_s_rec k s_6 s5) (open_s_wrt_s_rec k s_6 s')
  | (s_blame b5) => s_blame b5
  | (s_cast SS1 SS2 l5) => s_cast (open_SS_wrt_s_rec k s_6 SS1) (open_SS_wrt_s_rec k s_6 SS2) l5
  | (s_check SS5 s5 k5 l5) => s_check (open_SS_wrt_s_rec k s_6 SS5) (open_s_wrt_s_rec k s_6 s5) k5 l5
end
with open_SS_wrt_s_rec (k:nat) (s_6:s) (SS_6:SS) {struct SS_6}: SS :=
  match SS_6 with
  | (SS_refinement B5 s5) => SS_refinement B5 (open_s_wrt_s_rec (S k) s_6 s5)
  | (SS_darrow SS1 SS2) => SS_darrow (open_SS_wrt_s_rec k s_6 SS1) (open_SS_wrt_s_rec (S k) s_6 SS2)
end.

Definition open_F_wrt_s_rec (k:nat) (s_6:s) (F5:F) : F :=
  match F5 with
  | (F_appl s5) => F_appl (open_s_wrt_s_rec k s_6 s5)
  | (F_appr s5) => F_appr (open_s_wrt_s_rec k s_6 s5)
  | (F_check SS5 k5 l5) => F_check (open_SS_wrt_s_rec k s_6 SS5) k5 l5
end.

Definition open_SS_wrt_s s_6 SS_6 := open_SS_wrt_s_rec 0 SS_6 s_6.

Definition open_s_wrt_s s_6 s__7 := open_s_wrt_s_rec 0 s__7 s_6.

Definition open_F_wrt_s s_6 F5 := open_F_wrt_s_rec 0 F5 s_6.


(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_s_SS *)
Inductive lc_s : s -> Prop :=    (* defn lc_s *)
 | lc_s_var_f : forall (x5:x),
     (lc_s (s_var_f x5))
 | lc_s_const : forall (k5:k),
     (lc_s (s_const k5))
 | lc_s_lam : forall (SS5:SS) (s5:s),
     (lc_SS SS5) ->
      ( forall x5 , lc_s  ( open_s_wrt_s s5 (s_var_f x5) )  )  ->
     (lc_s (s_lam SS5 s5))
 | lc_s_app : forall (s5 s':s),
     (lc_s s5) ->
     (lc_s s') ->
     (lc_s (s_app s5 s'))
 | lc_s_blame : forall (b5:b),
     (lc_s (s_blame b5))
 | lc_s_cast : forall (SS1 SS2:SS) (l5:l),
     (lc_SS SS1) ->
     (lc_SS SS2) ->
     (lc_s (s_cast SS1 SS2 l5))
 | lc_s_check : forall (SS5:SS) (s5:s) (k5:k) (l5:l),
     (lc_SS SS5) ->
     (lc_s s5) ->
     (lc_s (s_check SS5 s5 k5 l5))
with lc_SS : SS -> Prop :=    (* defn lc_SS *)
 | lc_SS_refinement : forall (B5:B) (s5:s),
      ( forall x5 , lc_s  ( open_s_wrt_s s5 (s_var_f x5) )  )  ->
     (lc_SS (SS_refinement B5 s5))
 | lc_SS_darrow : forall (SS1 SS2:SS),
     (lc_SS SS1) ->
      ( forall x5 , lc_SS  ( open_SS_wrt_s SS2 (s_var_f x5) )  )  ->
     (lc_SS (SS_darrow SS1 SS2)).

(* defns LC_F *)
Inductive lc_F : F -> Prop :=    (* defn lc_F *)
 | lc_F_appl : forall (s5:s),
     (lc_s s5) ->
     (lc_F (F_appl s5))
 | lc_F_appr : forall (s5:s),
     (lc_s s5) ->
     (lc_F (F_appr s5))
 | lc_F_check : forall (SS5:SS) (k5:k) (l5:l),
     (lc_SS SS5) ->
     (lc_F (F_check SS5 k5 l5)).

(** free variables *)
Fixpoint sfv_s (s_6:s) : vars :=
  match s_6 with
  | (s_var_b nat) => {}
  | (s_var_f x5) => {{x5}}
  | (s_const k5) => {}
  | (s_lam SS5 s5) => (sfv_SS SS5) \u (sfv_s s5)
  | (s_app s5 s') => (sfv_s s5) \u (sfv_s s')
  | (s_blame b5) => {}
  | (s_cast SS1 SS2 l5) => (sfv_SS SS1) \u (sfv_SS SS2)
  | (s_check SS5 s5 k5 l5) => (sfv_SS SS5) \u (sfv_s s5)
end
with sfv_SS (SS_6:SS) : vars :=
  match SS_6 with
  | (SS_refinement B5 s5) => (sfv_s s5)
  | (SS_darrow SS1 SS2) => (sfv_SS SS1) \u (sfv_SS SS2)
end.

Definition sfv_F (F5:F) : vars :=
  match F5 with
  | (F_appl s5) => (sfv_s s5)
  | (F_appr s5) => (sfv_s s5)
  | (F_check SS5 k5 l5) => (sfv_SS SS5)
end.


(** substitutions *)
Fixpoint ssubst_s (s_6:s) (y5:x) (s__7:s) {struct s__7} : s :=
  match s__7 with
  | (s_var_b nat) => s_var_b nat
  | (s_var_f x5) => (if eq_var x5 y5 then s_6 else (s_var_f x5))
  | (s_const k5) => s_const k5
  | (s_lam SS5 s5) => s_lam (ssubst_SS s_6 y5 SS5) (ssubst_s s_6 y5 s5)
  | (s_app s5 s') => s_app (ssubst_s s_6 y5 s5) (ssubst_s s_6 y5 s')
  | (s_blame b5) => s_blame b5
  | (s_cast SS1 SS2 l5) => s_cast (ssubst_SS s_6 y5 SS1) (ssubst_SS s_6 y5 SS2) l5
  | (s_check SS5 s5 k5 l5) => s_check (ssubst_SS s_6 y5 SS5) (ssubst_s s_6 y5 s5) k5 l5
end
with ssubst_SS (s_6:s) (y5:x) (SS_6:SS) {struct SS_6} : SS :=
  match SS_6 with
  | (SS_refinement B5 s5) => SS_refinement B5 (ssubst_s s_6 y5 s5)
  | (SS_darrow SS1 SS2) => SS_darrow (ssubst_SS s_6 y5 SS1) (ssubst_SS s_6 y5 SS2)
end.

Definition ssubst_F (s_6:s) (y5:x) (F5:F) : F :=
  match F5 with
  | (F_appl s5) => F_appl (ssubst_s s_6 y5 s5)
  | (F_appr s5) => F_appr (ssubst_s s_6 y5 s5)
  | (F_check SS5 k5 l5) => F_check (ssubst_SS s_6 y5 SS5) k5 l5
end.


(* OTT generates a tactic that mentions env, so even though
   there are no environments here, we have to have the type 
   available. *)
Parameter env : Set.

(* denotations are only defined on constants. *)
Parameter denot : k -> k -> s.

(* I'd like to use 'S' for types (like the paper), but that 
   conflicts with nat's S in the generated code. *)
Parameter tyh   : k -> SS.

(* I don't know why OTT generates calls to these but doesn't 
   generate the definitions. But they're trivial. *)
Definition lc_B (B1 : B) := True.
Definition lc_k (k1 : k) := True.

(* Plugging an evaluation context with a term. *)
Definition Fplug (F1 : F) (s1 : s) :=
  match F1 with 
  | F_appl s2 => s_app s1 s2
  | F_appr s2 => s_app s2 s1 
  | F_check SS k l => s_check SS s1 k l 
  end.




(** definitions *)

(* defns Jctx *)
Inductive valid_ctx : F -> Prop :=    (* defn valid_ctx *)
 | valid_appl : forall (s5:s),
     lc_s s5 ->
     valid_ctx (F_appl s5)
 | valid_appr : forall (w5:s),
     is_w_of_s w5 ->
     is_w_of_s w5 ->
     lc_s w5 ->
     valid_ctx (F_appr w5)
 | valid_check : forall (SS5:SS) (k5:k) (l5:l),
     lc_SS SS5 ->
     lc_k k5 ->
     valid_ctx (F_check SS5 k5 l5).

(* defns Joph *)
Inductive reduceh : s -> s -> Prop :=    (* defn reduceh *)
 | F_Const : forall (k5 k':k),
     lc_k k5 ->
     lc_k k' ->
     reduceh (s_app (s_const k5) (s_const k'))  (denot  k5   k' ) 
 | F_Beta : forall (SS5:SS) (s12 w2:s),
     is_w_of_s w2 ->
      lc_s   ( (s_lam SS5 s12) )   ->
      lc_s  w2  ->
     reduceh (s_app  ( (s_lam SS5 s12) )  w2)  (open_s_wrt_s  s12   w2 ) 
 | F_CCheck : forall (B5:B) (s1 s2:s) (l5:l) (k5:k),
     lc_k k5 ->
      lc_SS  (SS_refinement B5 s1)  ->
      lc_SS  (SS_refinement B5 s2)  ->
     reduceh (s_app (s_cast (SS_refinement B5 s1) (SS_refinement B5 s2) l5) (s_const k5)) (s_check (SS_refinement B5 s2)  (open_s_wrt_s  s2   (s_const k5) )  k5 l5)
 | F_OK : forall (SS5:SS) (k5:k) (l5:l),
     lc_k k5 ->
      lc_SS  SS5  ->
     reduceh (s_check SS5 (s_const k_true) k5 l5) (s_const k5)
 | F_Fail : forall (SS5:SS) (k5:k) (l5:l),
     lc_k k5 ->
      lc_SS  SS5  ->
     reduceh (s_check SS5 (s_const k_false) k5 l5) (s_blame (b_blame l5))
 | F_CDecomp : forall (SS11 SS12 SS21 SS22:SS) (l5:l) (w' w5:s),
     is_w_of_s w5 ->
     is_w_of_s w' ->
     is_w_of_s w5 ->
     lc_s w5 ->
      lc_SS  (SS_darrow SS11 SS12)  ->
      lc_SS  (SS_darrow SS21 SS22)  ->
      lc_s  w'  ->
     reduceh (s_app  ( (s_app (s_cast (SS_darrow SS11 SS12) (SS_darrow SS21 SS22) l5) w5) )  w') (s_app (s_cast  (   open_SS_wrt_s  SS12   (s_app (s_cast SS21 SS11 l5) w')   )   (   open_SS_wrt_s  SS22   w'   )  l5)  ( (s_app w5  ( (s_app (s_cast SS21 SS11 l5) w') ) ) ) ).

(* defns JophT *)
Inductive steph : s -> s -> Prop :=    (* defn steph *)
 | F_Reduce : forall (s1 s2:s),
     reduceh s1 s2 ->
     steph s1 s2
 | F_Compat : forall (F5:F) (s1 s2:s),
     valid_ctx F5 ->
     steph s1 s2 ->
     steph  (Fplug  F5   s1 )   (Fplug  F5   s2 ) 
 | F_Blame : forall (F5:F) (l5:l),
     valid_ctx F5 ->
     steph  (Fplug  F5   (s_blame (b_blame l5)) )  (s_blame (b_blame l5)).

(* defns JophM *)
Inductive evalh : s -> s -> Prop :=    (* defn evalh *)
 | F_Refl : forall (s5:s),
     lc_s s5 ->
     evalh s5 s5
 | F_Step : forall (s5 s'' s':s),
     steph s5 s' ->
     evalh s' s'' ->
     evalh s5 s''.

(* defns Jparred *)
Inductive parreds : s -> s -> Prop :=    (* defn parreds *)
 | P_Refl : forall (s5:s),
     lc_s s5 ->
     parreds s5 s5
 | P_RConst : forall (k5:k) (w5:s) (k':k),
     is_w_of_s w5 ->
     lc_k k5 ->
     parreds w5 (s_const k') ->
     parreds (s_app (s_const k5) w5)  (denot  k5   k' ) 
 | P_RBeta : forall (L:vars) (SS5:SS) (s12 w2 s12' w2':s),
     is_w_of_s w2 ->
     is_w_of_s w2' ->
     lc_SS SS5 ->
      ( forall x5 , x5 \notin  L  -> parreds  ( open_s_wrt_s s12 (s_var_f x5) )   (open_s_wrt_s  s12'   (s_var_f x5) )  )  ->
     parreds w2 w2' ->
     parreds (s_app  ( (s_lam SS5 s12) )  w2)  (open_s_wrt_s  s12'   w2' ) 
 | P_RCCheck : forall (L:vars) (B5:B) (s1 s2:s) (l5:l) (k5:k) (s2':s),
     lc_k k5 ->
      lc_SS  (SS_refinement B5 s1)  ->
      ( forall x5 , x5 \notin  L  -> parreds  ( open_s_wrt_s s2 (s_var_f x5) )   ( open_s_wrt_s s2' (s_var_f x5) )  )  ->
     parreds (s_app (s_cast (SS_refinement B5 s1) (SS_refinement B5 s2) l5) (s_const k5)) (s_check (SS_refinement B5 s2')  (open_s_wrt_s  s2'   (s_const k5) )  k5 l5)
 | P_ROK : forall (SS5:SS) (k5:k) (l5:l),
     lc_k k5 ->
      lc_SS  SS5  ->
     parreds (s_check SS5 (s_const k_true) k5 l5) (s_const k5)
 | P_RFail : forall (SS5:SS) (k5:k) (l5:l),
     lc_k k5 ->
      lc_SS  SS5  ->
     parreds (s_check SS5 (s_const k_false) k5 l5) (s_blame (b_blame l5))
 | P_RCDecomp : forall (L:vars) (SS11 SS12 SS21 SS22:SS) (l5:l) (w1 w2:s) (SS12' SS21' SS11':SS) (w2':s) (SS22':SS) (w1':s),
     is_w_of_s w1 ->
     is_w_of_s w2 ->
     is_w_of_s w2' ->
     is_w_of_s w1' ->
     parredSS SS11 SS11' ->
      ( forall x5 , x5 \notin  L  -> parredSS  ( open_SS_wrt_s SS12 (s_var_f x5) )   (   open_SS_wrt_s  SS12'   (s_var_f x5)   )  )  ->
     parredSS SS21 SS21' ->
      ( forall x5 , x5 \notin  L  -> parredSS  ( open_SS_wrt_s SS22 (s_var_f x5) )   (   open_SS_wrt_s  SS22'   (s_var_f x5)   )  )  ->
     parreds w1 w1' ->
     parreds w2 w2' ->
     parreds (s_app  ( (s_app (s_cast (SS_darrow SS11 SS12) (SS_darrow SS21 SS22) l5) w1) )  w2) (s_app (s_cast  (   open_SS_wrt_s  SS12'   (s_app (s_cast SS21' SS11' l5) w2')   )   (   open_SS_wrt_s  SS22'   w2'   )  l5)  ( (s_app w1'  ( (s_app (s_cast SS21' SS11' l5) w2') ) ) ) )
 | P_Lam : forall (L:vars) (SS1:SS) (s12:s) (SS1':SS) (s12':s),
     parredSS SS1 SS1' ->
      ( forall x5 , x5 \notin  L  -> parreds  ( open_s_wrt_s s12 (s_var_f x5) )   ( open_s_wrt_s s12' (s_var_f x5) )  )  ->
     parreds (s_lam SS1 s12) (s_lam SS1' s12')
 | P_App : forall (s1 s2 s1' s2':s),
     parreds s1 s1' ->
     parreds s2 s2' ->
     parreds (s_app s1 s2) (s_app s1' s2')
 | P_Cast : forall (SS1 SS2:SS) (l5:l) (SS1' SS2':SS),
     parredSS SS1 SS1' ->
     parredSS SS2 SS2' ->
     parreds (s_cast SS1 SS2 l5) (s_cast SS1' SS2' l5)
 | P_Check : forall (SS5:SS) (s5:s) (k5:k) (l5:l) (SS':SS) (s':s),
     lc_k k5 ->
     parredSS SS5 SS' ->
     parreds s5 s' ->
     parreds (s_check SS5 s5 k5 l5) (s_check SS' s' k5 l5)
 | P_Blame : forall (F5:F) (l5:l),
     valid_ctx F5 ->
     parreds  (Fplug  F5   (s_blame (b_blame l5)) )  (s_blame (b_blame l5))
with parredSS : SS -> SS -> Prop :=    (* defn parredSS *)
 | P_SSRefl : forall (SS5:SS),
     lc_SS SS5 ->
     parredSS SS5 SS5
 | P_SSRefine : forall (L:vars) (B5:B) (s5 s':s),
     lc_B B5 ->
      ( forall x5 , x5 \notin  L  -> parreds  ( open_s_wrt_s s5 (s_var_f x5) )   ( open_s_wrt_s s' (s_var_f x5) )  )  ->
     parredSS (SS_refinement B5 s5) (SS_refinement B5 s')
 | P_SSFun : forall (L:vars) (SS1 SS2 SS1' SS2':SS),
     parredSS SS1 SS1' ->
      ( forall x5 , x5 \notin  L  -> parredSS  ( open_SS_wrt_s SS2 (s_var_f x5) )   ( open_SS_wrt_s SS2' (s_var_f x5) )  )  ->
     parredSS (SS_darrow SS1 SS2) (SS_darrow SS1' SS2').

(* defns JparredMs *)
Inductive parredsrs : s -> s -> Prop :=    (* defn parredsrs *)
 | P_ssRefl : forall (s5:s),
     lc_s s5 ->
     parredsrs s5 s5
 | P_ssStep : forall (s5 s'' s':s),
     parreds s5 s' ->
     parredsrs s' s'' ->
     parredsrs s5 s''.

(* defns JparredMSS *)
Inductive parredSrs : SS -> SS -> Prop :=    (* defn parredSrs *)
 | P_SsRefl : forall (SS5:SS),
     lc_SS SS5 ->
     parredSrs SS5 SS5
 | P_SsStep : forall (SS5 SS'' SS':SS),
     parredSS SS5 SS' ->
     parredSrs SS' SS'' ->
     parredSrs SS5 SS''.

(** infrastructure *)

(* additional definitions *)


(* instanciation of tactics *)

Ltac gather_atoms ::=
  let A := gather_atoms_with (fun x : vars => x) in
  let B := gather_atoms_with (fun x : var => {{ x }}) in
  let D1 := gather_atoms_with (fun x => sfv_SS x) in
  let D2 := gather_atoms_with (fun x => sfv_s x) in
  let D3 := gather_atoms_with (fun x => sfv_F x) in
  constr:(A \u B \u D1 \u D2 \u D3).

Hint Constructors valid_ctx reduceh steph evalh parreds parredSS parredsrs parredSrs lc_s lc_SS lc_F.




